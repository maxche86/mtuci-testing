# Новый ЛК +7

_Данный проект является реализацией клиентской части веб приложения новый личный кабинет для абонентов +7_

## Используемый стек:

`React`, `TypeScript`, `React Router Dom,` `React Hook Form`, `Axios`, стейт менеджер - `Zustand`, подход к написанию стилей CSS In JS - `Vanilla Extract`, бандлер для сборки проекта `Vite`.

**Версия NodeJS используемая на проекте - 22.11.0 LTS**

## Работа с GIT:

- Клонирование репозитория на локальную машину, желательно работать через SSH (плюсы очевидны, ненужно при каждом коммите вводить пароль, так же считается более секьюрным способом общения с удалённым репозиторием)

```bash
git clone git@git.ic-group.ru:showcases/front/lk-plus7-new.git
```

- Настройка пользователя, для корректного отображения в истории коммитов авторов и коммитеров:

```bash
git config --local user.name "Vasiliy Pupkin" #имя пользователя

git config --local user.email "Vasiliy.Pupkin@ic-group.ru" #email пользователя
```

- Разработку ведём в ветке `main` так же на эту ветку насроен CI/CD (всё что попадает в ветку `main` автоматом деплоится на DEV контур). Напрямую нельзя пушить ни в `main` ни в `dev` ветки, они защищены. Все коммиты попадают в ветку `main`. Предварительно MR должен быть проверен и апрувнут.

- Нейминг веток:

```bash
feature/NEW-<номер таски из Jira> - #если фича

bugfix/NEW-<номер таски с багом из Jira> - #если баг

hotfix/NEW-<номер таски из Jira> - #если срочный хотфикс
```

- Нейминг коммита:

```bash
<тип ветки>-<номер таски в Jira>: added или fixed или changed или deleted (краткое описание действия)

#например:
git commit -m "feature-1234: changed README.md file"
```

- Создание MR. После завершения работы над таской, пушатся все коммиты на удалённый репозиторий и уже в вебинтерфейсе GitLab создаётся MR в ветку `main` и выбирается ревьюер и асайнится на него (ревью должны проводить все члены команды, польза тут для всех). Открытые замечания к MR (они же в GitLab называются - threads) должны быть закрыты (зарезолвлены) только автором этих тредов. Если замечаний нет или все треды зарезолвлены, проверяющий должен поставить апрув, и мейнтейнер мержит ветку в `main`.

## Запуск приложения.

**Основные команды:**

- `npm run start ` или `npm start` - Собрать приложение в режиме разработки и запустить его на дев сервере;
- `npm run build` - Собрать приложение в билд для деплоя;
- `preview` - Запустить сбилженное приложение на локальном хосте. (может быть полезно для самопроверки, чтобы посмотреть как будет вести себя приложение на дев, тест и прод контурах, подтянулись ли все ассеты (картинки, шрифты и т.д.) правильно ли указаны импорты/экспорты разных модулей и прочее... );
- `npm run lint-all` - Запустить линтер по всему приложению

## Архитектура(структура) приложения.

Для лучшей масштабируемости и гибкости во время разработки, была принята архитектурная методология для фронтенд приложения [FSD](https://feature-sliced.design/ru/)

Приложение разбито на слои (слои в данной методологии это верхний уровень директорий):

- **App** (Приложение) самый верхний самый главный слой из него экспортируется само приложение для дальнейшего монтирования.
- **Pages** (Страницы) копозиционный слой для сборки страниц приложения, включащий в себя композицию из виджетов фичей и энтитис
- **Widgets** (Виджеты) копозиционный слой, включающий в себя фичи и энтитис (например хэдер, футер, навигация...)
- **Features** (Фичи/функции) действия пользователей над бизнес сущностями (энтитис), которые несут в себе какую-то бизнес ценность для пользователя и дают какой-то результат.
- **Entities** (Сущности) бизнес сущности, понятия из реального мира.
- **Shared** (Общий) общий слой для переиспользования каких то дополнительных библиотек, ui-kit, и прочий переиспользуемый во всём приложении код.

Слои состоят из слайсов — сильно сцепленных групп модулей. Feature-Sliced Design поддерживает низкую связанность, поэтому зависимости между слайсами регулируются правилом импортов для слоёв:

**_Модуль в слайсе может импортировать другие слайсы только в том случае, если они расположены на слоях строго ниже._**

Внутри слайса код может быть организован как угодно, и это не создаст никаких проблем до тех пор, пока срез имеет качественный публичный API. В этом суть правила публичного API для слайсов:

**_Каждый слайс (и сегмент на слоях, не имеющих слайсов) должен содержать определение публичного API.
Модули вне этого слайса/сегмента могут ссылаться только на публичный API, а не на внутреннюю файловую структуру этого слайса/сегмента._**

## Работа со стейт менеджером.

- Для удобства работы со стейт менеджером `Zustand`, в приложении присутствует обёртка `createStore` импортируется она из модуля `~shared/lib/store`. В это обёртку добавлены мидлвары `Redux Dev Tools` и `Immer`, чтобы каждый раз их не добавлять при создании стора. Первым агрументом наша кастомная функция принимаем колбэк такой же который принимает нативная функция, а вторым аргументом строку обозначающую имя стора, которая потом будет отображаться в девтулах.
- При создании стора нужно создать тип описывающий сам стейт и тип описывающий экшены над этим стейтом.
- Затем создаём сам стор с использованием нашего кастомного `createStore` прокидываем ему типы для того чтобы наш стор был типизированным и TS нам помогал и ограждал от ошибок, и конфигурируем стор. Когда конфигурируем экшены нужно не забыть что функция `set()` принимает 3 аргумента, первый - функцию колбэк которая изменяет состояние, второй аргумент от мидлвары `Immer` булевая переменная - `shouldReplace` тут передаём всегда`false`, и третий аргумент от мидлвары `Redux Dev Tools` тут передаём строку с именем экшена, чтобы в девтулах отслеживать их.
- Так же содаём селекторы которые нужны для получения конкретного поля из нашего стора

**Ниже представлен пример написания стора для абстрактного счётчика:**

```typescript
import { createStore } from '~shared/lib/store';

type CounterState = {
  counter: number;
};

type CounterActions = {
  increment: (value: number) => void;
  decrement: (value: number) => void;
};

export const useCounter = createStore<CounterState & CounterActions>(
  set => ({
    counter: 0,
    increment: value =>
      set(
        state => {
          state.counter += value;
        },
        false,
        'increment',
      ),
    decrement: value =>
      set(
        state => {
          state.counter -= value;
        },
        false,
        'decrement',
      ),
  }),
  'Counter',
);

export const counterSelector = (state: CounterState) => state.counter;
export const incrementSelector = (state: CounterActions) => state.increment;
export const decrementSelector = (state: CounterActions) => state.decrement;
```
